{
  "opcode": 9,
  "mnemonic": "JUMP_IF_FALSE",
  "description": "Conditional jump if top of stack is false or nil",
  "format": {
    "bytes": 5,
    "encoding": "09 [target:uint32_le]",
    "fields": [
      {
        "name": "opcode",
        "offset": 0,
        "size": 1,
        "type": "uint8",
        "value": 9
      },
      {
        "name": "target",
        "offset": 1,
        "size": 4,
        "type": "uint32",
        "endianness": "little",
        "description": "Absolute bytecode offset to jump to if condition is false"
      }
    ]
  },
  "stack_effect": {
    "before": ["...", "condition"],
    "after": ["..."],
    "pops": 1,
    "pushes": 0,
    "net_effect": "-1"
  },
  "operation": {
    "pseudocode": "value = stack.pop(); if (value == false || value == nil) instructionPointer = target",
    "steps": [
      "Read 4-byte target offset from bytecode",
      "Pop condition value from stack",
      "If value is false or nil, set instruction pointer to target",
      "Otherwise, advance instruction pointer by 5"
    ]
  },
  "examples": [
    {
      "smalltalk": "x > 0 ifTrue: [self doSomething]",
      "bytecode_sequence": [
        "PUSH_TEMPORARY_VARIABLE 0  ; push x",
        "PUSH_LITERAL 0             ; push 0",
        "SEND_MESSAGE > 1           ; send >",
        "JUMP_IF_FALSE 15           ; skip if false",
        "PUSH_SELF                  ; true branch",
        "SEND_MESSAGE doSomething 0"
      ],
      "explanation": "Conditional execution"
    }
  ],
  "notes": [
    "Only false and nil are considered false",
    "All other values (including 0) are considered true",
    "Pops the condition value from stack",
    "Used to implement ifTrue:, ifFalse:, and loops",
    "Target must be valid instruction boundary"
  ],
  "related_opcodes": [8, 10],
  "frequency": "very high",
  "complexity": "O(1)"
}
