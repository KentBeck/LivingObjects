#!/usr/bin/env python3
"""
Code generation tool for Smalltalk VM implementations.
Reads JSON schemas and generates implementation scaffolding.
"""

import json
import glob
from pathlib import Path
from typing import Dict, List, Any


class CodeGenerator:
    """Generate VM code from JSON specifications"""

    def __init__(self, specs_dir: str = "specs"):
        self.specs_dir = Path(specs_dir)

    def load_primitive_specs(self) -> List[Dict[str, Any]]:
        """Load all primitive specifications"""
        specs = []
        pattern = str(self.specs_dir / "primitives" / "schema" / "*.json")

        for schema_file in sorted(glob.glob(pattern)):
            with open(schema_file) as f:
                specs.append(json.load(f))

        return sorted(specs, key=lambda s: s["primitive_number"])

    def load_bytecode_specs(self) -> List[Dict[str, Any]]:
        """Load all bytecode specifications"""
        specs = []
        pattern = str(self.specs_dir / "bytecode" / "schema" / "*.json")

        for schema_file in sorted(glob.glob(pattern)):
            with open(schema_file) as f:
                specs.append(json.load(f))

        return sorted(specs, key=lambda s: s["opcode"])

    def generate_primitive_dispatch_python(self) -> str:
        """Generate Python primitive dispatch code"""
        specs = self.load_primitive_specs()

        code = '''"""
Auto-generated primitive dispatch code.
Generated from JSON specifications.
"""

from typing import Any, List
from vm_interface import VMInterface


class PrimitiveDispatcher:
    """Dispatches primitive method calls"""
    
    def __init__(self, vm: VMInterface):
        self.vm = vm
    
    def call_primitive(self, primitive_number: int, receiver: Any, args: List[Any]) -> Any:
        """
        Dispatch to appropriate primitive implementation.
        
        Args:
            primitive_number: Primitive number to call
            receiver: Message receiver
            args: Message arguments
        
        Returns:
            Result of primitive execution
        
        Raises:
            NotImplementedError: If primitive not implemented
            TypeError: If arguments have wrong types
            Various: Primitive-specific errors
        """
'''

        for spec in specs:
            num = spec["primitive_number"]
            selector = spec["selector"]
            desc = spec["description"]

            code += f'''
        if primitive_number == {num}:  # {selector}
            """{desc}"""
            return self.primitive_{num}(receiver, args)
'''

        code += """
        raise NotImplementedError(f"Primitive {primitive_number} not implemented")
"""

        # Generate stub implementations
        code += "\n    # Primitive implementations\n"

        for spec in specs:
            num = spec["primitive_number"]
            selector = spec["selector"]
            desc = spec["description"]
            receiver_type = spec["receiver"]["type"]
            arg_types = [arg["type"] for arg in spec["arguments"]]
            return_type = spec["returns"]["type"]

            code += f'''
    def primitive_{num}(self, receiver: Any, args: List[Any]) -> Any:
        """
        Primitive {num}: {selector}
        {desc}
        
        Receiver: {receiver_type}
        Arguments: {arg_types}
        Returns: {return_type}
        """
        # TODO: Implement primitive {num}
        raise NotImplementedError("Primitive {num} not yet implemented")
'''

        return code

    def generate_bytecode_interpreter_python(self) -> str:
        """Generate Python bytecode interpreter"""
        specs = self.load_bytecode_specs()

        code = '''"""
Auto-generated bytecode interpreter.
Generated from JSON specifications.
"""

from typing import Any, List
from vm_interface import VMInterface


class BytecodeInterpreter:
    """Interprets Smalltalk bytecode"""
    
    def __init__(self, vm: VMInterface):
        self.vm = vm
        self.ip = 0  # Instruction pointer
    
    def execute(self, bytecodes: bytes, method: Any) -> Any:
        """
        Execute bytecode sequence.
        
        Args:
            bytecodes: Bytecode array to execute
            method: CompiledMethod containing literals, etc.
        
        Returns:
            Result of execution
        """
        self.ip = 0
        
        while self.ip < len(bytecodes):
            opcode = bytecodes[self.ip]
            self.ip += 1
            
            # Dispatch to instruction handler
'''

        for spec in specs:
            opcode = spec["opcode"]
            mnemonic = spec["mnemonic"]

            code += f"""
            if opcode == {opcode}:  # {mnemonic}
                self.execute_{mnemonic.lower()}(bytecodes, method)
                continue
"""

        code += """
            raise ValueError(f"Unknown opcode: {opcode}")
        
        # Return top of stack
        return self.vm.pop()
"""

        # Generate instruction handlers
        code += "\n    # Instruction handlers\n"

        for spec in specs:
            mnemonic = spec["mnemonic"]
            desc = spec["description"]
            format_info = spec["format"]

            code += f'''
    def execute_{mnemonic.lower()}(self, bytecodes: bytes, method: Any) -> None:
        """
        {mnemonic}: {desc}
        Format: {format_info['encoding']}
        Size: {format_info['bytes']} bytes
        """
        # TODO: Implement {mnemonic}
        raise NotImplementedError("{mnemonic} not yet implemented")
'''

        return code

    def generate_test_adapter_python(self) -> str:
        """Generate test adapter template"""
        return '''"""
Test adapter for your VM implementation.
Adapt your VM to the VMInterface for testing.
"""

from typing import Any, List
from vm_interface import VMInterface


class YourVMAdapter(VMInterface):
    """
    Adapter that wraps your VM implementation.
    Replace YourVM with your actual VM class.
    """
    
    def __init__(self):
        # Initialize your VM here
        self.your_vm = YourVM()
        self._stack = []
    
    def push(self, value: Any) -> None:
        """Push value onto stack"""
        self._stack.append(value)
    
    def pop(self) -> Any:
        """Pop and return top value"""
        if not self._stack:
            raise RuntimeError("Stack underflow")
        return self._stack.pop()
    
    def call_primitive(self, primitive_number: int) -> Any:
        """
        Call primitive method.
        Receiver and arguments should already be on stack.
        """
        # Adapt to your VM's primitive calling convention
        # This is just an example:
        
        # Get receiver and arguments from stack
        # (number of args depends on primitive)
        receiver = self.pop()
        args = []  # Pop appropriate number of args
        
        # Call your VM's primitive dispatcher
        result = self.your_vm.call_primitive(primitive_number, receiver, args)
        
        # Push result back onto stack
        self.push(result)
        return result
    
    @property
    def stack(self) -> List[Any]:
        """Return current stack contents"""
        return self._stack.copy()
    
    def reset(self) -> None:
        """Reset VM state"""
        self._stack.clear()
        # Reset other VM state as needed


class YourVM:
    """Your actual VM implementation"""
    
    def call_primitive(self, primitive_number: int, receiver: Any, args: List[Any]) -> Any:
        """Your VM's primitive implementation"""
        # Implement your primitive dispatch here
        raise NotImplementedError()
'''

    def generate_all(self, output_dir: str = "generated"):
        """Generate all code files"""
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)

        # Generate primitive dispatcher
        print("Generating primitive dispatcher...")
        primitive_code = self.generate_primitive_dispatch_python()
        with open(output_path / "primitive_dispatcher.py", "w") as f:
            f.write(primitive_code)

        # Generate bytecode interpreter
        print("Generating bytecode interpreter...")
        bytecode_code = self.generate_bytecode_interpreter_python()
        with open(output_path / "bytecode_interpreter.py", "w") as f:
            f.write(bytecode_code)

        # Generate test adapter
        print("Generating test adapter template...")
        adapter_code = self.generate_test_adapter_python()
        with open(output_path / "vm_adapter.py", "w") as f:
            f.write(adapter_code)

        print(f"\nGenerated files in {output_dir}/:")
        print("  - primitive_dispatcher.py")
        print("  - bytecode_interpreter.py")
        print("  - vm_adapter.py")
        print("\nNext steps:")
        print("1. Review generated code")
        print("2. Implement TODOs in generated files")
        print("3. Adapt vm_adapter.py to your VM")
        print("4. Run test suite: pytest specs/primitives/tests/ -v")


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Generate VM code from JSON specifications"
    )
    parser.add_argument(
        "--output", default="generated", help="Output directory for generated code"
    )
    parser.add_argument("--specs", default="specs", help="Specifications directory")

    args = parser.parse_args()

    generator = CodeGenerator(args.specs)
    generator.generate_all(args.output)


if __name__ == "__main__":
    main()
